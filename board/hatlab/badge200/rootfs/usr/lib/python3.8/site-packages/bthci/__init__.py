#!/usr/bin/env python3

import os
import re
import sys
import time
import struct
import logging
import subprocess
import threading
from typing import Type
import dbus


from scapy.layers.bluetooth import HCI_Cmd_LE_Create_Connection
from scapy.layers.bluetooth import HCI_Cmd_LE_Read_Remote_Used_Features as HCI_Cmd_LE_Read_Remote_Features

from scapy.layers.bluetooth import HCI_Event_Command_Status

# Temporary solution for PyBlueZ problems
import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)

from dbus import SystemBus

from pyclui import Logger

from bluetooth._bluetooth import SOL_HCI, SOL_BLUETOOTH

from bluetooth._bluetooth import MSG_WAITALL

from bluetooth._bluetooth import hci_open_dev
from bluetooth._bluetooth import hci_close_dev

from bluetooth._bluetooth import HCI_FILTER
from bluetooth._bluetooth import hci_filter_new
from bluetooth._bluetooth import hci_filter_clear
from bluetooth._bluetooth import hci_filter_set_ptype
from bluetooth._bluetooth import hci_filter_set_event
from bluetooth._bluetooth import hci_filter_set_opcode

from bluetooth._bluetooth import cmd_opcode_pack
from bluetooth._bluetooth import hci_send_cmd

from bluetooth._bluetooth import OGF_LINK_CTL
from bluetooth._bluetooth import OCF_INQUIRY
from bluetooth._bluetooth import OCF_INQUIRY_CANCEL
from bluetooth._bluetooth import OCF_EXIT_PERIODIC_INQUIRY
from bluetooth._bluetooth import OCF_CREATE_CONN
from bluetooth._bluetooth import OCF_DISCONNECT
from bluetooth._bluetooth import OCF_READ_REMOTE_FEATURES
from bluetooth._bluetooth import OCF_READ_REMOTE_VERSION
OCF_READ_REMOTE_EXT_FEATURES = 0x001C
OCF_CREATE_CONN_CANCEL = 0x0008

from bluetooth._bluetooth import OGF_HOST_CTL
from bluetooth._bluetooth import OCF_RESET
from bluetooth._bluetooth import OCF_SET_EVENT_FLT
from bluetooth._bluetooth import OCF_WRITE_SCAN_ENABLE
from bluetooth._bluetooth import OCF_READ_LOCAL_NAME
from bluetooth._bluetooth import OCF_WRITE_INQUIRY_MODE
from bluetooth._bluetooth import OCF_WRITE_AUTH_ENABLE
from bluetooth._bluetooth import OCF_READ_CLASS_OF_DEV
from bluetooth._bluetooth import OCF_READ_PAGE_TIMEOUT
from bluetooth._bluetooth import OCF_WRITE_PAGE_TIMEOUT
from bluetooth._bluetooth import OCF_WRITE_EXT_INQUIRY_RESPONSE
OCF_REMOTE_NAME_REQUEST = 0x0019
OCF_READ_EXT_PAGE_TIMEOUT = 0x007E
OCF_WRITE_EXT_PAGE_TIMEOUT = 0x007F

from bluetooth._bluetooth import OGF_INFO_PARAM
from bluetooth._bluetooth import OCF_READ_BD_ADDR


OGF_LE_CTRL = 0x08 # Event Code (1 B) + Parameter Total Length (1 B)
OCF_LE_SET_ADVERTISING_PARAMETERS      = 0x0006
OCF_LE_SET_ADVERTISING_DATA            = 0x0008
OCF_LE_SET_SCAN_RESPONSE_DATA          = 0x0009
OCF_LE_SET_ADVERTISING_ENABLE          = 0x000A
OCF_LE_SET_SCAN_ENABLE                 = 0x000C
OCF_LE_CREATE_CONNECTION               = 0x000D
OCF_LE_READ_REMOTE_FEATURES            = 0x0016
OCF_LE_SET_PERIODIC_ADVERTISING_ENABLE = 0x0040


from bluetooth._bluetooth import BT_SECURITY
from bluetooth._bluetooth import BT_SECURITY_SDP, BT_SECURITY_LOW, BT_SECURITY_MEDIUM, BT_SECURITY_HIGH #, BT_SECURITY_FIPS

AUTHENTICATION_FAILURE            = 0x05
REMOTE_USER_TERMINATED_CONNECTION = 0x13
UNSPECIFIED_ERROR                 = 0x1f

HCI_PKT_TYPE_SIZE   = 1
EVT_CODE_SIZE       = 1
PARAM_TOTAL_LEN     = 1
NON_EVT_PARAMS_SIZE = HCI_PKT_TYPE_SIZE + EVT_CODE_SIZE + PARAM_TOTAL_LEN
PENDING_STATUS = 0x00
SUCCESS_STATUS = 0x00
# EVT_*_SIZE indicates Parameter_Total_Length of the HCI event packet
from bluetooth._bluetooth import HCI_EVENT_PKT
from bluetooth._bluetooth import HCI_MAX_EVENT_SIZE # bluez set this to 260, but the max is 257
from bluetooth._bluetooth import EVT_CMD_COMPLETE
# The size of event parameters of HCI_Command_Complete event is variable, so 
# EVT_CMD_COMPLETE_SIZE only defines the fixed part, Num_HCI_Command_Packets and 
# Command_Opcode (total 3 bytes).
from bluetooth._bluetooth import EVT_CMD_COMPLETE_SIZE
from bluetooth._bluetooth import EVT_INQUIRY_COMPLETE
from bluetooth._bluetooth import EVT_CONN_COMPLETE
from bluetooth._bluetooth import EVT_CONN_COMPLETE_SIZE
from bluetooth._bluetooth import EVT_DISCONN_COMPLETE
from bluetooth._bluetooth import EVT_DISCONN_COMPLETE_SIZE
from bluetooth._bluetooth import EVT_CMD_STATUS
from bluetooth._bluetooth import EVT_CMD_STATUS_SIZE
from bluetooth._bluetooth import EVT_REMOTE_NAME_REQ_COMPLETE
from bluetooth._bluetooth import EVT_REMOTE_NAME_REQ_COMPLETE_SIZE
from bluetooth._bluetooth import EVT_READ_REMOTE_FEATURES_COMPLETE
from bluetooth._bluetooth import EVT_READ_REMOTE_FEATURES_COMPLETE_SIZE
from bluetooth._bluetooth import EVT_READ_REMOTE_VERSION_COMPLETE
from bluetooth._bluetooth import EVT_READ_REMOTE_VERSION_COMPLETE_SIZE
from bluetooth._bluetooth import EVT_INQUIRY_RESULT
from bluetooth._bluetooth import EVT_INQUIRY_RESULT_WITH_RSSI
from bluetooth._bluetooth import EVT_EXTENDED_INQUIRY_RESULT


EVT_READ_REMOTE_EXT_FEATURES_COMPLETE = 0x23
EVT_READ_REMOTE_EXT_FEATURES_COMPLETE_SIZE = 13

EVT_LE_META = 0x3E
SUBEVT_LE_CONNECTION_COMPLETE           = 0x01
SUBEVT_LE_ADVERTISING_REPORT            = 0x02
SUBEVT_LE_READ_REMOTE_FEATURES_COMPLETE = 0x04
SUBEVT_LE_SCAN_REQUEST_RECEIVED         = 0x13 # HCI_LE_Scan_Request_Received event 在 Bluetooth 5.0 中加入
SUBEVT_LE_SCAN_REQUEST_RECEIVED_SIZE    = 9

BD_ADDR_LEN = 6

LINK_CTRL_CMD_OGF = 0x01
HCI_CTRL_BASEBAND_CMD_OGF = 0x03

# HCI_Write_Scan_Enable command, Scan_Enable Parameter
ISCAN  = 0x01
PSCAN  = 0x02
PISCAN = 0x03





# // bluetooth/hci.h
# struct hci_filter {
#     uint32_t type_mask;
#     uint32_t event_mask[2];
#     uint16_t opcode;
# };
HCI_FILTER_SIZE = 14 # 4 + 4*2 + 2

BLUEZ_NAME = 'org.bluez' # The well-known name of bluetoothd
IFACE_OBJ_MGR = 'org.freedesktop.DBus.ObjectManager'

logger = Logger(__name__, logging.INFO)


class HCI:
    def __init__(self, iface:str = None):
        if iface is None:
            try:
                iface = HCI.get_default_hcistr()
            except IndexError:
                raise RuntimeError('HCI.__init__, Can\'t get default hci string')
            
        try:
            self.devid = HCI.hcistr2devid(iface)
        except TypeError:
            self.devid = -1
        
        if self.devid == -1:
            raise ValueError('Invalid HCI device: %s' % iface)


    @classmethod
    def get_default_hcistr(cls) -> str:
        '''
        Exceptions - IndexError
        '''
        default_hcistr = HCI.get_hci_list()[-1]    
        return default_hcistr


    @classmethod
    def verify_hcistr(cls, s:str) -> bool:
        '''If '''
        if re.fullmatch('hci(0|[1-9][0-9]*)', s) is not None:
            return True
        else:
            return False


    @classmethod
    def get_hci_list(cls) -> list:
        '''return - hci string list, like `['hci1', 'hci2']`'''
        hcistrs = []
        sys_bus = SystemBus()
        objs = dbus.Interface(sys_bus.get_object(BLUEZ_NAME, '/'), 
            IFACE_OBJ_MGR).GetManagedObjects()

        for obj_path, props in objs.items():
            logger.debug('obj_path: {}'.format(obj_path))
            hcistr = obj_path.split('/')[-1]
            if HCI.verify_hcistr(hcistr):
                hcistrs.append(hcistr)

        sys_bus.close()

        return hcistrs


    @classmethod
    def hcistr2devid(cls, s:str) -> int:
        '''
        s - hci string
        Exceptions - TypeError
        '''
        logger.debug('parameter s: {}'.format(s))
        devid = re.findall('0|[1-9][0-9]*', s)
        if len(devid) == 1:
            devid = int(devid[0])
        else:
            devid = -1

        return devid


    ################### Link Control Commands #################################
    def inquiry(self, cmd_params:dict):
        '''
        cmd_params - {
                         'LAP': 0x9E8B33
                         'Inquiry_Length': 0x01 to 0x30, 
                         'Num_Responses': 0x00
                     }
        '''
        dd = hci_open_dev(self.devid)

        bin_cmd_params = cmd_params['LAP'].to_bytes(3, 'little') + \
            cmd_params['Inquiry_Length'].to_bytes(1, 'little') + \
            cmd_params['Num_Responses'].to_bytes(1, 'little')

        # If no filter is set, we can't receive any inquiry result.
        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_INQUIRY_COMPLETE)
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(dd, OGF_LINK_CTL, OCF_INQUIRY, bin_cmd_params)

        pp_inquiry_result_thread = threading.Thread(
            target=self.pp_inquiry_result_rt, args=[EVT_INQUIRY_RESULT]
        )
        pp_inquiry_result_with_rssi_thread = threading.Thread(
            target=self.pp_inquiry_result_rt, args=[EVT_INQUIRY_RESULT_WITH_RSSI]
        )
        pp_ext_inquiry_result_thread = threading.Thread(
            target=self.pp_inquiry_result_rt, args=[EVT_EXTENDED_INQUIRY_RESULT]
        )

        pp_inquiry_result_thread.start()
        pp_inquiry_result_with_rssi_thread.start()
        pp_ext_inquiry_result_thread.start()

        while True:
            data = dd.recv(1024)
            if len(data) < 3:
                continue
            
            event_code = data[1]
            print(data)
            if event_code == EVT_INQUIRY_COMPLETE:
                logger.debug('HCI_Inquiry_Complete')
                break

        hci_close_dev(dd.fileno())
        return data

        # flt = hci_filter_new()
        # hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        # hci_filter_set_event(flt, EVT_EXTENDED_INQUIRY_RESULT)
        # hci_filter_set_opcode(flt, cmd_opcode_pack(OGF_LINK_CTL, OCF_INQUIRY))
        # dd.setsockopt(SOL_HCI, HCI_FILTER, flt)


    def inquiry_cancel(self) -> dict:
        '''
        Return -- {
            'Num_HCI_Command_Packets': int,
            'Command_Opcode': int,
            'Status': int
        }
        '''
        dd = hci_open_dev(self.devid)

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)
        hci_filter_set_opcode(
            flt, cmd_opcode_pack(OGF_LINK_CTL, OCF_INQUIRY_CANCEL))
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(dd, OGF_LINK_CTL, OCF_INQUIRY_CANCEL)
        event_params = dd.recv(3+EVT_CMD_COMPLETE_SIZE+1)[3:]
        num_hci_cmd_pkts, cmd_opcode, status = struct.unpack('<BHB', event_params)
        event_params = {
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode': cmd_opcode,
            'Status': status
        }
    
        hci_close_dev(dd.fileno())
        return event_params

    def exit_periodic_inquiry_mode(self) -> dict:
        '''
        Return -- {
            'Num_HCI_Command_Packets': int,
            'Command_Opcode': int,
            'Status': int
        }
        '''
        dd = hci_open_dev(self.devid)

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)
        hci_filter_set_opcode(
            flt, cmd_opcode_pack(OGF_LINK_CTL, OCF_EXIT_PERIODIC_INQUIRY))
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(dd, OGF_LINK_CTL, OCF_EXIT_PERIODIC_INQUIRY)

        event_params = dd.recv(3+EVT_CMD_COMPLETE_SIZE+1)[3:]
        num_hci_cmd_pkts, cmd_opcode, status = struct.unpack('<BHB', event_params)
        event_params = {
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode': cmd_opcode,
            'Status': status
        }
        
        hci_close_dev(dd.fileno())
        return status

    def create_connection(self, cmd_params:dict):
        '''
        cmd_params -- {
                          'BD_ADDR': str,
                          'Packet_Type': int,
                          'Page_Scan_Repetition_Mode': ,
                          'Reserved': ,
                          'Clock_Offset': ,
                          'Allow_Role_Switch':
                      }
        '''
        dd = hci_open_dev(self.devid)

        bin_cmd_params = bytes.fromhex(
            cmd_params['BD_ADDR'].replace(':', ''))[::-1] + \
            cmd_params['Packet_Type'].to_bytes(2, 'little') + \
            cmd_params['Page_Scan_Repetition_Mode'].to_bytes(1, 'little') + \
            cmd_params['Reserved'].to_bytes(1, 'little') + \
            cmd_params['Clock_Offset'].to_bytes(2, 'little') + \
            cmd_params['Allow_Role_Switch'].to_bytes(1, 'little')
        
        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CONN_COMPLETE)
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(dd, OGF_LINK_CTL, OCF_CREATE_CONN, bin_cmd_params)

        while True:
            event_params = dd.recv(3+EVT_CONN_COMPLETE_SIZE)[3:]
            status, conn_handle, bd_addr, link_type, encrypt_enabled = \
                struct.unpack('<BH6sBB', event_params)
            event_params = {
                'Status': status,
                'Connection_Handle': conn_handle,
                'BD_ADDR': ':'.join(['%02x'%b for b in bd_addr[::-1]]),
                'Link_Type': link_type,
                'Encryption_Enabled': encrypt_enabled,
            }

            if event_params['BD_ADDR'].lower() == cmd_params['BD_ADDR'].lower():
                break
            else:
                print('[WARNING] Another HCI_Connection_Complete event detected', event_params)

        hci_close_dev(dd.fileno())
        return event_params
        
    def disconnect(self, cmd_params:dict) -> dict:
        '''
        cmd_params -- {
            'Connection_Handle': int, 2 bytes,
            'Reason': int, 1 bytes
        }
        '''
        dd = hci_open_dev(self.devid)
        
        flt = hci_filter_new()
        hci_filter_clear(flt)
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_DISCONN_COMPLETE)
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        bin_cmd_params = cmd_params['Connection_Handle'].to_bytes(2, 'little') + \
            cmd_params['Reason'].to_bytes(1, 'little')

        hci_send_cmd(dd, OGF_LINK_CTL, OCF_DISCONNECT, bin_cmd_params)

        # Receive and exclude HCI packet type (1 B)
        event_params = dd.recv(3+EVT_DISCONN_COMPLETE_SIZE)[3:] 
        status, conn_handle, reason, = struct.unpack(
            '<BHB', event_params)

        event_params = {
            'Status': status,
            'Connection_Handle': conn_handle,
            'Reason': reason
        }

        hci_close_dev(dd.fileno())
        return event_params


    def create_connection_cancel(self, cmd_params:dict) -> dict:
        '''
        cmd_params -- {
            'BD_ADDR': str
        }
        '''
        dd = hci_open_dev(self.devid)

        bin_cmd_params = bytes.fromhex(cmd_params['BD_ADDR'].replace(':', '')[::-1])

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)
        hci_filter_set_opcode(
            flt, cmd_opcode_pack(OGF_LINK_CTL, OCF_CREATE_CONN_CANCEL))
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(dd, OGF_LINK_CTL, OCF_CREATE_CONN_CANCEL, bin_cmd_params)
        
        event_params = dd.recv(3+EVT_CMD_COMPLETE_SIZE+7)[3:]
        num_hci_cmd_pkts, cmd_opcode, status, \
            bdaddr = struct.unpack('<BHB6s', event_params)

        hci_close_dev(dd.fileno())
        return event_params


    def remote_name_request(self, cmd_params={'BD_ADDR': bytes(6),
        'Page_Scan_Repetition_Mode': 0x01, 'Reserved': 0x00, 'Clock_Offset': 0x0000}) -> dict:
        '''HCI_Remote_Name_Request command

        The controller will response HCI_Remote_Name_Request_Complete event.

        在 inquiry 的过程中发送该命令，将导致 inquiry 被立即结束，即 controller 
        返回成功的 HCI_Inquiry_Complete event。不过此时，请求远端名字的流程不会被影响。

        BD_ADDR - Big-endian. It will be converted to little-endian internally.
        '''
        sock = hci_open_dev(self.devid)

        bin_cmd_params = struct.pack('<6sBBH', cmd_params['BD_ADDR'][::-1],
            cmd_params['Page_Scan_Repetition_Mode'], cmd_params['Reserved'],
            cmd_params['Clock_Offset'])

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_REMOTE_NAME_REQ_COMPLETE)
        sock.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(sock, OGF_LINK_CTL, OCF_REMOTE_NAME_REQUEST, 
            bin_cmd_params)

        event_params = sock.recv(NON_EVT_PARAMS_SIZE + \
            EVT_REMOTE_NAME_REQ_COMPLETE_SIZE)[3:]
        status, bd_addr, remote_name = struct.unpack('<B6s248s', event_params)
        event_params = {
            'Status': status,
            'BD_ADDR': bd_addr,
            'Remote_Name': remote_name
        }
        return event_params


    def read_remote_supported_features(self, cmd_params:dict) -> dict:
        '''
        cmd_params -- {'Connection_Handle': 0x0000 to 0x0EFF}
        '''
        dd = hci_open_dev(self.devid)

        bin_cmd_params = cmd_params['Connection_Handle'].to_bytes(2, 'little')

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_READ_REMOTE_FEATURES_COMPLETE)
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(dd, OGF_LINK_CTL, OCF_READ_REMOTE_FEATURES, 
            bin_cmd_params)

        while True:
            event_params = dd.recv(3+EVT_READ_REMOTE_FEATURES_COMPLETE_SIZE)[3:]
            status, conn_handle, lmp_features = struct.unpack('<BH8s', event_params)
            event_params = {
                'Status': status,
                'Connection_Handle': conn_handle,
                'LMP_Features': lmp_features
            }

            if event_params['Connection_Handle'] == cmd_params['Connection_Handle']:
                break

        hci_close_dev(dd.fileno())
        return event_params


    def read_remote_extended_features(self, cmd_params:dict) -> dict:
        '''
        cmd_params -- {
                          'Connection_Handle': 0x0000 to 0x0EFF,
                          'Page_Number': int
                      }
        '''
        dd = hci_open_dev(self.devid)

        bin_cmd_params = cmd_params[
            'Connection_Handle'].to_bytes(2, 'little') + \
            cmd_params['Page_Number'].to_bytes(1, 'little')

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_READ_REMOTE_EXT_FEATURES_COMPLETE)
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(dd, OGF_LINK_CTL, OCF_READ_REMOTE_EXT_FEATURES, 
            bin_cmd_params)

        while True:
            event_params = dd.recv(3 + \
                EVT_READ_REMOTE_EXT_FEATURES_COMPLETE_SIZE)[3:]
            status, conn_handle, page_num, max_page_num, ext_lmp_features = \
                struct.unpack('<BHBB8s', event_params)
            event_params = {
                'Status': status,
                'Connection_Handle': conn_handle,
                'Page_Number': page_num,
                'Maximum_Page_Number': max_page_num,
                'Extended_LMP_Features': ext_lmp_features
            }

            if event_params['Connection_Handle'] == cmd_params['Connection_Handle'] and \
                event_params['Page_Number'] == cmd_params['Page_Number']:
                break

        hci_close_dev(dd.fileno())
        return event_params


    def read_remote_version_information(self, cmd_params:dict) -> dict:
        '''
        cmd_params -- {
            'Connection_Handle': 0x0000
        }
        '''
        dd = hci_open_dev(self.devid)

        bin_cmd_params = cmd_params['Connection_Handle'].to_bytes(2, 'little')

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_READ_REMOTE_VERSION_COMPLETE)
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(dd, OGF_LINK_CTL, OCF_READ_REMOTE_VERSION, bin_cmd_params)

        while True:
            event_params = dd.recv(3 + \
                EVT_READ_REMOTE_VERSION_COMPLETE_SIZE)[3:]
            status, conn_handle, ver, manufacturer_name, subver = \
                struct.unpack('<BHBHH', event_params)
            event_params = {
                'Status': status,
                'Connection_Handle': conn_handle,
                'Version': ver,
                'Manufacturer_Name': manufacturer_name,
                'Subversion': subver
            }

            if event_params['Connection_Handle'] == cmd_params['Connection_Handle']:
                break

        hci_close_dev(dd.fileno())
        return event_params

    ################## Controller & Baseband Commands #########################
    def reset(self) -> dict:
        dd = hci_open_dev(self.devid)

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)
        hci_filter_set_opcode(flt, cmd_opcode_pack(OGF_HOST_CTL, OCF_RESET))
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(dd, OGF_HOST_CTL, OCF_RESET)
        event_params = dd.recv(3+EVT_CMD_COMPLETE_SIZE+1)[3:]
        num_hci_cmd_pkts, cmd_opcode, status = struct.unpack('<BHB', event_params)
        event_params = {
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode': cmd_opcode,
            'Status': status
        }
    
        hci_close_dev(dd.fileno())
        return event_params


    def write_scan_enable(self, cmd_params={'Scan_Enable': 0x00}) -> dict:
        '''HCI_Read_Scan_Enable command
        
        The controller will response HCI_Command_Complete event.
        '''
        sock = hci_open_dev(self.devid)

        bin_cmd_params = cmd_params['Scan_Enable'].to_bytes(1, 'little')

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)
        hci_filter_set_opcode(
            flt, cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_SCAN_ENABLE))
        sock.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(sock, OGF_HOST_CTL, OCF_WRITE_SCAN_ENABLE, bin_cmd_params)
        event_params = sock.recv(3+EVT_CMD_COMPLETE_SIZE+1)[3:]
        num_hci_cmd_pkts, cmd_opcode, status = struct.unpack('<BHB', event_params)
        event_params = {
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode': cmd_opcode,
            'Status': status
        }

        hci_close_dev(sock.fileno())
        return event_params


    def set_event_filter(self, cmd_params:dict) -> dict:
        '''A little complicated. see the core specification 
        BLUETOOTH CORE SPECIFICATION Version 5.2 | Vol 4, Part E page 2078. 
        Only support Filter_Type = 0x00 now.
        '''
        dd = hci_open_dev(self.devid)

        bin_cmd_params = cmd_params['Filter_Type'].to_bytes(1, 'little')

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)
        hci_filter_set_opcode(flt, cmd_opcode_pack(OGF_HOST_CTL, OCF_SET_EVENT_FLT))
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(dd, OGF_HOST_CTL, OCF_SET_EVENT_FLT, bin_cmd_params)
        event_params = dd.recv(3+EVT_CMD_COMPLETE_SIZE+1)[3:]
        num_hci_cmd_pkts, cmd_opcode, status = struct.unpack('<BHB', event_params)
        event_params = {
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode': cmd_opcode,
            'Status': status
        }

        hci_close_dev(dd.fileno())
        return event_params


    def read_local_name(self) -> dict:
        dd = hci_open_dev(self.devid)

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)
        hci_filter_set_opcode(
            flt, cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_LOCAL_NAME))
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(dd, OGF_HOST_CTL, OCF_READ_LOCAL_NAME)

        event_params = dd.recv(3+EVT_CMD_COMPLETE_SIZE+249)[3:]
        num_hci_cmd_pkts, cmd_opcode, status, local_name = struct.unpack('<BHB248s', event_params)
        event_params = {
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode': cmd_opcode,
            'Status': status,
            'Local_Name': local_name.decode()
        }

        hci_close_dev(dd.fileno())
        return event_params


    def write_inquiry_mode(self, cmd_params={'Inquiry_Mode': 0x00}) -> dict:
        dd = hci_open_dev(self.devid)

        bin_cmd_params = cmd_params['Inquiry_Mode'].to_bytes(1, 'little')

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)
        hci_filter_set_opcode(
            flt, cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_INQUIRY_MODE))
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(dd, OGF_HOST_CTL, OCF_WRITE_INQUIRY_MODE, bin_cmd_params)
        event_params = dd.recv(3+EVT_CMD_COMPLETE_SIZE+1)[3:]
        num_hci_cmd_pkts, cmd_opcode, status = struct.unpack('<BHB', event_params)
        event_params = {
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode': cmd_opcode,
            'Status': status
        }
        
        hci_close_dev(dd.fileno())
        return event_params


    def read_page_timeout(self) -> dict:
        dd = hci_open_dev(self.devid)

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)
        hci_filter_set_opcode(
            flt, cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_PAGE_TIMEOUT))
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(dd, OGF_HOST_CTL, OCF_READ_PAGE_TIMEOUT)
        event_params = dd.recv(3+EVT_CMD_COMPLETE_SIZE+3)[3:]
        num_hci_cmd_pkts, cmd_opcode, status, page_timeout = struct.unpack('<BHBH', event_params)
        event_params = {
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode': cmd_opcode,
            'Status': status,
            'Page_Timeout': page_timeout
        }

        hci_close_dev(dd.fileno())
        return event_params


    def write_page_timeout(self, cmd_params={'Page_Timeout': 0x2000}) -> dict:
        dd = hci_open_dev(self.devid)

        bin_cmd_params = cmd_params['Page_Timeout'].to_bytes(2, 'little')

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)
        hci_filter_set_opcode(
            flt, cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_PAGE_TIMEOUT))
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(dd, OGF_HOST_CTL, OCF_WRITE_PAGE_TIMEOUT, bin_cmd_params)
        event_params = dd.recv(3+EVT_CMD_COMPLETE_SIZE+3)[3:]
        num_hci_cmd_pkts, cmd_opcode, status = struct.unpack('<BHB', event_params)
        event_params = {
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode': cmd_opcode,
            'Status': status
        }

        hci_close_dev(dd.fileno())
        return event_params


    def write_authentication_enable(self, cmd_params={'Authentication_Enable': 0x00}) -> dict:
        dd = hci_open_dev(self.devid)

        bin_cmd_params = cmd_params['Authentication_Enable'].to_bytes(1, 'little')

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)
        hci_filter_set_opcode(
            flt, cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_AUTH_ENABLE))
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(dd, OGF_HOST_CTL, OCF_WRITE_AUTH_ENABLE, bin_cmd_params)
        event_params = dd.recv(3+EVT_CMD_COMPLETE_SIZE+3)[3:]
        num_hci_cmd_pkts, cmd_opcode, status = struct.unpack('<BHB', event_params)
        event_params = {
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode': cmd_opcode,
            'Status': status
        }

        hci_close_dev(dd.fileno())
        return event_params


    def read_class_of_device(self) -> dict:
        dd = hci_open_dev(self.devid)

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)
        hci_filter_set_opcode(
            flt, cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_CLASS_OF_DEV))
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(dd, OGF_HOST_CTL, OCF_READ_CLASS_OF_DEV)

        event_params = dd.recv(3+HCI_MAX_EVENT_SIZE)[3:]
        num_hci_cmd_pkts, cmd_opcode, status, cod = struct.unpack('<BHB3s', event_params)
        event_params = {
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode': cmd_opcode,
            'Status': status,
            'Class_Of_Device': cod[::-1]
        }

        hci_close_dev(dd.fileno())
        return event_params


    def read_extended_page_timeout(self):
        dd = hci_open_dev(self.devid)

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)
        hci_filter_set_opcode(
            flt, cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_EXT_PAGE_TIMEOUT))
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(dd, OGF_HOST_CTL, OCF_READ_EXT_PAGE_TIMEOUT)

        event_params = dd.recv(3+EVT_CMD_COMPLETE_SIZE+3)[3:]
        num_hci_cmd_pkts, cmd_opcode, status, \
           ext_page_timeout = struct.unpack('<BHBH', event_params)
        event_params = {
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode': cmd_opcode,
            'Status': status,
            'Extended_Page_Timeout': ext_page_timeout
        }

        hci_close_dev(dd.fileno())
        return event_params

    def write_extended_inquiry_response(self):
        '''HCI_Write_Extended_Inquiry_Response'''
        dd = hci_open_dev(self.devid)

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)
        hci_filter_set_opcode(
            flt, cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_EXT_INQUIRY_RESPONSE))
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        fec_required = b'\x00'
        payload = b'\xFF\x08\x41\x41' * 59 + b'\xFF\x09\x42\x42'

        hci_send_cmd(dd, OGF_HOST_CTL, OCF_WRITE_EXT_INQUIRY_RESPONSE, fec_required+payload)

        event_params = dd.recv(3+EVT_CMD_COMPLETE_SIZE+3)[3:]
        # print(event_params)
        num_hci_cmd_pkts, cmd_opcode, status = struct.unpack('<BHB', event_params)
        event_params = {
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode': cmd_opcode,
            'Status': status,
        }

        hci_close_dev(dd.fileno())
        return event_params

    #################### Informational Parameters ###############################
    def read_bdaddr(self) -> dict:
        '''HCI_Read_BD_ADDR command
        
        The controller will response HCI_Command_Complete event.
        '''
        sock = hci_open_dev(self.devid)
        if sock.fileno() < 0:
            raise RuntimeError('Failed to create HCI socket. No Bluetooth adapter?')

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)
        hci_filter_set_opcode(
            flt, cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BD_ADDR))
        sock.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(sock, OGF_INFO_PARAM, OCF_READ_BD_ADDR)
        event_params = sock.recv(HCI_MAX_EVENT_SIZE)[3:]
        num_hci_cmd_pkts, cmd_opcode, status, bd_addr = struct.unpack("<BHB6s", event_params)
        bd_addr = ["%02X"%b for b in bd_addr]
        bd_addr.reverse()
        event_params = {
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode': cmd_opcode,
            'Status': status,
            'BD_ADDR': ':'.join(bd_addr)
        }
        
        hci_close_dev(sock.fileno())
        return event_params


    #################### LE Controller commands ###############################
    def le_set_advertising_parameters(self, cmd_params={
        'Advertising_Interval_Min': 0x0800, 
        'Advertising_Interval_Max': 0x0800,
        'Advertising_Type': 0x00, # ADV_IND
        'Own_Address_Type': 0x00, # Public Device Address
        'Peer_Address_Type': 0x00, # Public Device Address
        'Peer_Address': bytes(6), # Take big-endian and then convert to little-endian
        'Advertising_Channel_Map': 0x07, # 37, 38, 39
        'Advertising_Filter_Policy': 0x00 # Process scan and connection requests from all devices
    }) -> dict:
        '''HCI_LE_Set_Advertising_Parameters'''
        sock = hci_open_dev(self.devid)
        
        bin_cmd_params = struct.pack('<HHBBB6sBB', 
            cmd_params['Advertising_Interval_Min'], cmd_params['Advertising_Interval_Max'],
            cmd_params['Advertising_Type'], cmd_params['Own_Address_Type'], 
            cmd_params['Peer_Address_Type'], cmd_params['Peer_Address'][::-1], 
            cmd_params['Advertising_Channel_Map'], cmd_params['Advertising_Filter_Policy']
        )

        # bin_cmd_params = cmd_params['Advertising_Interval_Min'].to_bytes(2, 'little') + \
        #     cmd_params['Advertising_Interval_Max'].to_bytes(2, 'little') + \
        #     cmd_params['Advertising_Type'].to_bytes(1, 'little') + \
        #     cmd_params['Own_Address_Type'].to_bytes(1, 'little') + \
        #     cmd_params['Peer_Address_Type'].to_bytes(1, 'little') + \
        #     cmd_params['Peer_Address'][::-1] + \
        #     cmd_params['Advertising_Channel_Map'].to_bytes(1, 'little') + \
        #     cmd_params['Advertising_Filter_Policy'].to_bytes(1, 'little')
        
        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)

        SUBEVT_LE_CONNECTION_COMPLETE

        sock.setsockopt(SOL_HCI, HCI_FILTER, flt)
        
        hci_send_cmd(sock, OGF_LE_CTRL, OCF_LE_SET_ADVERTISING_PARAMETERS, bin_cmd_params)
        event_params = sock.recv(3+EVT_CMD_COMPLETE_SIZE+1)[3:]
        num_hci_cmd_pkts, cmd_opcode, status = struct.unpack('<BHB', event_params)
        event_params = {
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode': cmd_opcode,
            'Status': status
        }
    
        hci_close_dev(sock.fileno())
        return event_params


    def le_set_advertising_data(self, cmd_params={
        'Advertising_Data_Length': 0x1f,
        'Advertising_Data': bytes(0x1f)}) -> dict:
        '''HCI_LE_Set_Advertising_Data'''
        sock = hci_open_dev(self.devid)

        bin_cmd_params = cmd_params['Advertising_Data_Length'].to_bytes(1, 'little') + \
            cmd_params['Advertising_Data']

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)
        hci_filter_set_opcode(
            flt, cmd_opcode_pack(OGF_LE_CTRL, OCF_LE_SET_ADVERTISING_DATA))
        sock.setsockopt(SOL_HCI, HCI_FILTER, flt)
        
        hci_send_cmd(sock, OGF_LE_CTRL, OCF_LE_SET_ADVERTISING_DATA, bin_cmd_params)
        event_params = sock.recv(3+EVT_CMD_COMPLETE_SIZE+1)[3:]
        num_hci_cmd_pkts, cmd_opcode, status = struct.unpack('<BHB', event_params)
        event_params = {
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode': cmd_opcode,
            'Status': status
        }

        hci_close_dev(sock.fileno())
        return event_params


    def le_set_scan_response_data(self, cmd_params={
        'Scan_Response_Data_Length': 0x1f,
        'Scan_Response_Data': bytes(0x1f)}) -> dict:
        sock = hci_open_dev(self.devid)

        bin_cmd_params = cmd_params['Scan_Response_Data_Length'].to_bytes(1, 'little') + \
            cmd_params['Scan_Response_Data']

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)
        hci_filter_set_opcode(
            flt, cmd_opcode_pack(OGF_LE_CTRL, OCF_LE_SET_SCAN_RESPONSE_DATA))
        sock.setsockopt(SOL_HCI, HCI_FILTER, flt)
        
        hci_send_cmd(sock, OGF_LE_CTRL, OCF_LE_SET_SCAN_RESPONSE_DATA, bin_cmd_params)
        event_params = sock.recv(3+EVT_CMD_COMPLETE_SIZE+1)[3:]
        num_hci_cmd_pkts, cmd_opcode, status = struct.unpack('<BHB', event_params)
        event_params = {
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode': cmd_opcode,
            'Status': status
        }

        hci_close_dev(sock.fileno())
        return event_params


    def le_set_advertising_enable(self, cmd_params={'Advertising_Enable': 0x00}) -> dict:
        '''HCI_LE_Set_Advertising_Enable'''
        sock = hci_open_dev(self.devid)

        bin_cmd_params = struct.pack('<B', cmd_params['Advertising_Enable'])

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)
        hci_filter_set_opcode(
            flt, cmd_opcode_pack(OGF_LE_CTRL, OCF_LE_SET_ADVERTISING_ENABLE))
        sock.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(sock, OGF_LE_CTRL, OCF_LE_SET_ADVERTISING_ENABLE, bin_cmd_params)

        event_params = sock.recv(3+EVT_CMD_COMPLETE_SIZE+1)[3:]
        num_hci_cmd_pkts, cmd_opcode, status = struct.unpack('<BHB', event_params)
        event_params = {
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode': cmd_opcode,
            'Status': status
        }
        hci_close_dev(sock.fileno())
        return event_params


    def le_set_scan_enable(self, cmd_params:dict):
        '''
        cmd_params -- {
                          'LE_Scan_Enable': int 0 or 1,
                          'Filter_Duplicates': int 0 or 1
                      }
        '''
        dd = hci_open_dev(self.devid)

        bin_cmd_params = cmd_params['LE_Scan_Enable'].to_bytes(1, 'little') + \
            cmd_params['Filter_Duplicates'].to_bytes(1, 'little')

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)
        hci_filter_set_opcode(
            flt, cmd_opcode_pack(OGF_LE_CTRL, OCF_LE_SET_SCAN_ENABLE))
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(dd, OGF_LE_CTRL, OCF_LE_SET_SCAN_ENABLE, bin_cmd_params)
        event_params = dd.recv(3+EVT_CMD_COMPLETE_SIZE+1)[3:]
        num_hci_cmd_pkts, cmd_opcode, status = struct.unpack('<BHB', event_params)
        event_params = {
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode': cmd_opcode,
            'Status': status
        }

        if event_params['Status'] != 0x00:
            raise RuntimeError(
                'Status of HCI_LE_Set_Scan_Enable command: 0x%02x'%event_params['Status'])

        if not cmd_params['LE_Scan_Enable']:
            return event_params

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_LE_META)
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        while True:
            event_params = dd.recv(3+HCI_MAX_EVENT_SIZE)[3:]
            if event_params[0] != SUBEVT_LE_ADVERTISING_REPORT:
                continue

            num_reports = event_params[1]
            if num_reports == 1:
                event_type, addr_type, addr = struct.unpack('<BB6s', 
                    event_params[2:10])
                print('Event_Type:', event_type)
                print('Address_Type:', addr_type)
                print('Address:', addr)

        hci_close_dev(dd.fileno())
        return event_params
    
    
    def le_create_connection(self, cmd_params:HCI_Cmd_LE_Create_Connection) -> dict:
        ''''''
        dd = hci_open_dev(self.devid)

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_STATUS)
        hci_filter_set_opcode(flt, 
            cmd_opcode_pack(OGF_LE_CTRL, OCF_LE_CREATE_CONNECTION))
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(dd, OGF_LE_CTRL, OCF_LE_CREATE_CONNECTION, bytes(cmd_params))
        event_params = dd.recv(NON_EVT_PARAMS_SIZE + \
            EVT_CMD_STATUS_SIZE)[NON_EVT_PARAMS_SIZE:]
        status, num_hci_cmd_pkts, cmd_opcode = struct.unpack('<BBH', event_params)
        event_params = {
            'Status':                  status,
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode':          cmd_opcode
        }

        if event_params['Status'] != PENDING_STATUS:
            raise RuntimeError('Status of HCI_LE_Create_Connection: 0x%02x'%event_params['Status'])

        hci_filter_set_event(flt, EVT_LE_META)
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        while True:
            event_params = dd.recv(NON_EVT_PARAMS_SIZE + \
                HCI_MAX_EVENT_SIZE)[NON_EVT_PARAMS_SIZE:]
            subevent_code = event_params[0]
            status = event_params[1]
                
            if subevent_code != SUBEVT_LE_CONNECTION_COMPLETE:
                logger.debug(event_params)
                continue

            if status != SUCCESS_STATUS:
                raise RuntimeError('Status of HCI_LE_Connection_Complete event: 0x%02x'%event_params[1])

            conn_hdl, role, ptype, addr, conn_inter, conn_latency, supervision_timeout, master_clock_accuracy = struct.unpack('<HBB6sHHHB', 
                event_params[2:])
            event_params = {
                'Subevent_Code':        SUBEVT_LE_CONNECTION_COMPLETE,
                'Status':               SUCCESS_STATUS,
                'Connection_Handle':    conn_hdl,
                'Role':                 role,
                'Peer_Address_Type':    ptype,
                'Peer_Address':         addr,
                'Connection_Interval':  conn_inter,
                'Connection_Latency':   conn_latency,
                'Supervision_Timeout':  supervision_timeout,
                'Master_Clock_Accurac': master_clock_accuracy
            }

            return event_params
            # elif event_params[0] == SUBEVT_LE_READ_REMOTE_FEATURES_COMPLETE:
            #     conn_hdl, le_features = struct.unpack('<H8s', event_params[2:])
            #     event_params = {
            #         'Subevent_Code':        SUBEVT_LE_READ_REMOTE_FEATURES_COMPLETE,
            #         'Status':               SUCCESS_STATUS,
            #         'Connection_Handle':    conn_hdl,
            #         'LE_Features':          le_features
            #     }
            #     retval.append(event_params)

            # if len(retval) == 2:
            #     return retval

    def le_read_remote_features(self, 
        cmd_params:HCI_Cmd_LE_Read_Remote_Features) -> dict:
        ''' '''
        dd = hci_open_dev(self.devid)
        
        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_STATUS)
        hci_filter_set_opcode(flt, 
            cmd_opcode_pack(OGF_LE_CTRL, OCF_LE_READ_REMOTE_FEATURES))
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(dd, OGF_LE_CTRL, OCF_LE_READ_REMOTE_FEATURES, 
            bytes(cmd_params))
        event_params = dd.recv(NON_EVT_PARAMS_SIZE + \
            EVT_CMD_STATUS_SIZE)[NON_EVT_PARAMS_SIZE:]
        status, num_hci_cmd_pkts, cmd_opcode = struct.unpack('<BBH', event_params)
        event_params = {
            'Status':                  status,
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode':          cmd_opcode
        }

        if event_params['Status'] != PENDING_STATUS:
            raise RuntimeError('Status of HCI_LE_Read_Remote_Features: 0x%02x'%event_params['Status'])

        # Receive HCI_LE_Read_Remote_Features_Complete event
        hci_filter_set_event(flt, EVT_LE_META)
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        while True:
            event_params = dd.recv(NON_EVT_PARAMS_SIZE + \
                HCI_MAX_EVENT_SIZE)[NON_EVT_PARAMS_SIZE:]
            subevent_code = event_params[0]
            status = event_params[1]

            if subevent_code != SUBEVT_LE_READ_REMOTE_FEATURES_COMPLETE:
                logger.debug(event_params)
                continue

            if status != SUCCESS_STATUS:
                raise RuntimeError('Status of HCI_LE_Read_Remote_Features_Complete event: 0x%02x'%status)

            conn_hdl, le_features = struct.unpack('<H8s', event_params[2:])
            event_params = {
                'Subevent_Code':        SUBEVT_LE_READ_REMOTE_FEATURES_COMPLETE,
                'Status':               SUCCESS_STATUS,
                'Connection_Handle':    conn_hdl,
                'LE_Features':          le_features
            }
            return event_params
   

    def le_set_periodic_advertising_enable(self, cmd_params={
        'Enable': 0x01,
        'Advertising_Handle': 0x00
    }):
        '''HCI_LE_Set_Periodic_Advertising_Enable'''
        sock = hci_open_dev(self.devid)

        bin_cmd_params = struct.pack('<BB', cmd_params['Enable'], cmd_params['Advertising_Handle'])

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_CMD_COMPLETE)
        hci_filter_set_opcode(
            flt, cmd_opcode_pack(OGF_LE_CTRL, OCF_LE_SET_PERIODIC_ADVERTISING_ENABLE))
        sock.setsockopt(SOL_HCI, HCI_FILTER, flt)

        hci_send_cmd(sock, OGF_LE_CTRL, OCF_LE_SET_PERIODIC_ADVERTISING_ENABLE, bin_cmd_params)
        event_params = sock.recv(3+EVT_CMD_COMPLETE_SIZE+1)[3:]
        num_hci_cmd_pkts, cmd_opcode, status = struct.unpack('<BHB', event_params)
        event_params = {
            'Num_HCI_Command_Packets': num_hci_cmd_pkts,
            'Command_Opcode': cmd_opcode,
            'Status': status
        }
        
        hci_close_dev(sock.fileno())
        return event_params

        

def hci_write_local_name(params:bytes, iface='hci0'):
    ogf = HCI_CTRL_BASEBAND_CMD_OGF
    ocf = 0x0013

    params = ' '.join([hex(b) for b in params])
    hcitool_cmd = gen_hcitool_cmd(ogf, ocf, params, iface)

    print(subprocess.getoutput(hcitool_cmd))


def hci_link_Key_request_reply(bd_addr:str, link_key:str, iface='hci0'):
    '''BLUETOOTH CORE SPECIFICATION Version 5.1 | Vol 2, Part E page 825, 7.1.10 Link Key Request Reply command'''
    ogf = LINK_CTRL_CMD_OGF
    ocf = 0x000B

    # HCI command parameter using litten-endian
    bd_addr = ' '.join(['0x' + e for e in bd_addr.split(':')[::-1]])
    print(bd_addr)
    link_key = ' '.join([hex(b) for b in bytes.fromhex(link_key)])
    print(link_key)

    params = bd_addr + ' ' + link_key
    hcitool_cmd = gen_hcitool_cmd(ogf, ocf, params, iface)

    print(subprocess.getoutput(hcitool_cmd))


def hci_read_stored_link_key(bd_addr='00:00:00:00:00:00', read_all_flag=0x01, iface='hci0'):
    '''BLUETOOTH CORE SPECIFICATION Version 5.1 | Vol 2, Part E page 966, 7.3.8 Read Stored Link Key command'''
    ogf = HCI_CTRL_BASEBAND_CMD_OGF
    ocf = 0x000D
    
    bd_addr = ' '.join(['0x' + e for e in bd_addr.split(':')[::-1]])
    read_all_flag = hex(read_all_flag)

    params = ' '.join([bd_addr, read_all_flag])

    hcitool_cmd = gen_hcitool_cmd(ogf, ocf, params, iface)
    print(subprocess.getoutput(hcitool_cmd))


def hci_write_stored_link_key(bd_addrs: list, link_keys:list, iface='hci0'):
    '''BLUETOOTH CORE SPECIFICATION Version 5.1 | Vol 2, Part E page 968, 7.3.9 Write Stored Link Key command.'''
    ogf = HCI_CTRL_BASEBAND_CMD_OGF
    ocf = 0x0011

    if (len(bd_addrs) != len(link_keys)):
        print("[ERROR] BD_ADDRs and Link Keys is not one-to-one correspondence.")
        return False
    
    num_keys_to_write = len(link_keys)

    temp = ''
    for bd_addr in bd_addrs:
        temp +=  ' '.join(
            ['0x' + e for e in bd_addr.split(':')[::-1]]
    ) + ' '
    bd_addrs = temp
    print(bd_addrs)

    temp = ''
    for link_key in link_keys:
        temp += ' '.join(
        [hex(b) for b in bytes.fromhex(link_key)]
    ) + ' '
    link_keys = temp
    print(link_keys)

    params = hex(num_keys_to_write) + ' ' + bd_addrs + ' ' \
        + link_keys

    hcitool_cmd = gen_hcitool_cmd(ogf, ocf, params, iface)
    print(subprocess.getoutput(hcitool_cmd))


def hci_delete_stored_link_key(bd_addr='00:00:00:00:00:00', del_all_flag=0x01, iface='hci0'):
    "BLUETOOTH CORE SPECIFICATION Version 5.1 | Vol 2, Part E page 970, 7.3.10 Delete Stored Link Key command"
    ogf = HCI_CTRL_BASEBAND_CMD_OGF
    ocf = 0x0012

    bd_addr = ' '.join(['0x' + e for e in bd_addr.split(':')[::-1]])
    del_all_flag = hex(del_all_flag)
    params = ' '.join([bd_addr, del_all_flag])

    hcitool_cmd = gen_hcitool_cmd(ogf, ocf, params)
    print(subprocess.getoutput(hcitool_cmd))


def hci_write_simple_pairing_mode(simple_pairing_mode=0x00, iface='hci0'):
    '''7.3.59 Write Simple Pairing Mode command'''
    ogf = HCI_CTRL_BASEBAND_CMD_OGF
    ocf = 0x0056

    simple_pairing_mode = hex(simple_pairing_mode)
    params = simple_pairing_mode

    hcitool_cmd = gen_hcitool_cmd(ogf, ocf, params)
    print(subprocess.getoutput(hcitool_cmd))


def gen_hcitool_cmd(ogf:int, ocf:int, params:str, iface='hci0') -> str:
    '''构造执行任意 HCI command 的 hcitool 命令。'''
    cmd_args = ['hcitool', '-i', iface, 'cmd', hex(ogf), hex(ocf), params]
    cmd = ' '.join(cmd_args)
    return cmd


class __Test:
    @classmethod
    def scan_undiscoverable_dev(cls):
        import multiprocessing

        #hci_read_page_timeout()
        #hci_write_page_timeout(0x0200) # 0x0500 较稳定
        #hci_read_page_timeout()

        # p1 = multiprocessing.Process(target=job,args=(1,2))

        # range(, )

        #hci_create_connection('3C:28:6D:E0:58:F7')
        for i in range(0x000000, 0x100000):
            addr = '3c:28:6d:'+':'.join('%02x'%b for b in i.to_bytes(3, 'big', signed=False))
            print(addr)
            #print('HCI connect', addr)
            #status, bdaddr = hci_create_connection(addr)
            #hci_create_connection(addr)
            time.sleep(0.5)
            # if status == 0:
            #     print(status, bdaddr)

    @classmethod
    def pp_le_scanner_addr(cls):
        hci = HCI('hci0')
        hci.le_set_advertising_parameters()

        bytes.fromhex('020106020aeb0303ff00')+bytes(0x1f-10)
        hci.le_set_advertising_data({
            'Advertising_Data_Length': 0x12,
            'Advertising_Data': bytes.fromhex('020106020aeb0303ff000709424c45435446')+bytes(0x1f-0x12)
        })
        
        hci.le_set_scan_response_data({
            'Scan_Response_Data_Length': 0x0a,
            'Scan_Response_Data': bytes.fromhex('020106020aeb0303ff00')+bytes(0x1f-0x0a)
        })

        hci.le_set_advertising_enable({'Advertising_Enable': 0x01})

        dd = hci_open_dev(0)

        flt = hci_filter_new()
        hci_filter_set_ptype(flt, HCI_EVENT_PKT)
        hci_filter_set_event(flt, EVT_LE_META)
        dd.setsockopt(SOL_HCI, HCI_FILTER, flt)

        while True:
            event_params = dd.recv(3+SUBEVT_LE_SCAN_REQUEST_RECEIVED_SIZE)[3:]
            if event_params[0] != SUBEVT_LE_SCAN_REQUEST_RECEIVED:
                continue
            
            subevt_code, adv_handle, scanner_addr_type, scanner_addr = struct.unpack('<BBB6s', event_params)
            event_params = {
                'Subevent_Code': subevt_code,
                'Advertising_Handle': adv_handle,
                'Scanner_Address_Type': scanner_addr_type,
                'Scanner_Address': scanner_addr
            }

            print(event_params)

        hci_close_dev(dd.fileno())


def __test():
    hci = HCI('hci0')
    # event_params = hci.le_create_connection(HCI_Cmd_LE_Create_Connection(
    #     paddr=bytes.fromhex('18:D9:8F:D8:BC:2C'.replace(':', ''))[::-1], 
    #     patype='public'))
    # print(event_params)

    # event_params = hci.le_create_connection(HCI_Cmd_LE_Create_Connection(
    #     paddr=bytes.fromhex('18:D9:8F:D8:CC:4E'.replace(':', ''))[::-1], 
    #     patype='public'))
    # print(event_params)

    event_params = hci.le_create_connection(HCI_Cmd_LE_Create_Connection(
        paddr=bytes.fromhex('3C:CD:5D:0E:A2:FE'.replace(':', ''))[::-1], 
        patype='public'))
    print(event_params)

    

    # print(BT_SECURITY_SDP, BT_SECURITY_LOW, BT_SECURITY_MEDIUM, BT_SECURITY_HIGH)
    

if __name__ == '__main__':
    __test()
